<?xml version="1.0" encoding="utf-8"?>
<ManagementPack SchemaVersion="2.0" ContentReadable="true" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Manifest>
    <Identity>
      <ID>Atea.Windows.Service.Monitoring</ID>
      <Version>1.0.3.324</Version>
    </Identity>
    <Name>Atea.Windows.Service.Monitoring</Name>
    <References>
      <Reference Alias="MSNL">
        <ID>Microsoft.SystemCenter.NTService.Library</ID>
        <Version>7.0.8560.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Health">
        <ID>System.Health.Library</ID>
        <Version>7.0.8427.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <EntityTypes>
      <ClassTypes>
        <ClassType ID="Atea.Windows.Service.Seed" Accessibility="Public" Abstract="false" Base="Windows!Microsoft.Windows.LocalApplication" Hosted="true" Singleton="false">
          <Property ID="RegistryPath" Type="string" />
        </ClassType>
        <ClassType ID="Atea.Windows.Service.Service" Base="MSNL!Microsoft.SystemCenter.OwnProcessNTService" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false"></ClassType>
        <ClassType ID="Atea.Windows.Service.SharedService" Base="MSNL!Microsoft.SystemCenter.SharedProcessNTService" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false"></ClassType>
      </ClassTypes>
    </EntityTypes>
    <ModuleTypes>
      <DataSourceModuleType ID="Atea.Windows.Service.AutoServiceDiscoveryDS" Accessibility="Public" Batching="false">
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.Discovery.MapperSchema</SchemaType>
            <SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Debug" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClassId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="InstanceSettings" type="SettingsType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Filter" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ServiceExceptions" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="Debug" Selector="$Config/Debug$" ParameterType="bool" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="ServiceExceptions" Selector="$Config/ServiceExceptions$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval>$Config/IntervalSeconds$</Interval>
                    <SyncTime />
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PropertyBag" TypeID="Atea.Windows.Service.AutoServiceDiscoveryVBSProbe">
                <ComputerName>$Config/ComputerName$</ComputerName>
                <Debug>$Config/Debug$</Debug>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <ServiceExceptions>$Config/ServiceExceptions$</ServiceExceptions>
              </ProbeAction>
              <ConditionDetection ID="Mapper" TypeID="System!System.Discovery.ClassSnapshotDataMapper">
                <ClassId>$Config/ClassId$</ClassId>
                <InstanceSettings>$Config/InstanceSettings$</InstanceSettings>
              </ConditionDetection>
              <ConditionDetection ID="Filter" TypeID="System!System.ExpressionFilter">
                <Expression>$Config/Filter$</Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="Mapper">
                <Node ID="Filter">
                  <Node ID="PropertyBag">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.Discovery.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Atea.Windows.Service.ServiceDiscoveryDS" Accessibility="Public" Batching="false">
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.Discovery.MapperSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ScriptName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" name="UseServiceDisplayName" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Debug" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClassId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="InstanceSettings" type="SettingsType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="UseServiceDisplayName" Selector="$Config/UseServiceDisplayName$" ParameterType="bool" />
          <OverrideableParameter ID="Debug" Selector="$Config/Debug$" ParameterType="bool" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval>$Config/IntervalSeconds$</Interval>
                    <SyncTime />
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PropertyBag" TypeID="Atea.Windows.Service.Probe.VBSPropertyBag">
                <ScriptName>$Config/ScriptName$</ScriptName>
                <ComputerName>$Config/ComputerName$</ComputerName>
                <UseServiceDisplayName>$Config/UseServiceDisplayName$</UseServiceDisplayName>
                <Debug>$Config/Debug$</Debug>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection ID="Mapper" TypeID="System!System.Discovery.ClassSnapshotDataMapper">
                <ClassId>$Config/ClassId$</ClassId>
                <InstanceSettings>$Config/InstanceSettings$</InstanceSettings>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="Mapper">
                <Node ID="PropertyBag">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.Discovery.Data</OutputType>
      </DataSourceModuleType>
      <ProbeActionModuleType ID="Atea.Windows.Service.Probe.AddServicePS" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element name="ServiceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="RegistryPath" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="ServiceName" Selector="$Config/ServiceName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <ProbeAction ID="PSProbe" TypeID="Windows!Microsoft.Windows.PowerShellProbe">
                <ScriptName>Add-MonitoredServiceKey.ps1</ScriptName>
                <ScriptBody><![CDATA[param(
	[string] $serviceName,
	[string] $registryPath = "SOFTWARE\Atea\WinSvc"
)

$registryPath = "HKLM:\$registryPath"

if (!(Test-Path $registryPath)) {
	Write-Host ("{0} does not exist, will create key." -f $registryPath)
	New-Item $registryPath -Force
}
New-ItemProperty -Path $registryPath -Name $serviceName -PropertyType String -Force

Write-Host "`nNew service key added`n`nPlease wait for next discovery, `nor restart the Microsoft Monitoring agent to force a discovery."
]]></ScriptBody>
                <SnapIns />
                <Parameters>
                  <Parameter>
                    <Name>serviceName</Name>
                    <Value>$Config/ServiceName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>registryPath</Name>
                    <Value>$Config/RegistryPath$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <StrictErrorHandling>true</StrictErrorHandling>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PSProbe" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Windows!Microsoft.Windows.SerializedObjectData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </ProbeActionModuleType>
      <ProbeActionModuleType ID="Atea.Windows.Service.AutoServiceDiscoveryVBSProbe" Accessibility="Internal" Batching="false" PassThrough="false">
        <Configuration>
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Debug" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ServiceExceptions" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction ID="PropertyBag" TypeID="Windows!Microsoft.Windows.ScriptPropertyBagProbe">
                <ScriptName>AteaAutoSvcPBScript.vbs</ScriptName>
                <Arguments>$Config/ComputerName$ $Config/Debug$ "$Config/ServiceExceptions$"</Arguments>
                <ScriptBody><![CDATA[Option Explicit

Dim computerName, keyPath, wmiObject, automaticServices, automaticService, serviceName, debugEnabled, scriptParameters, serviceClass, serviceExceptions, standardExclusions, wmiQuery, xylemExclusions
Dim scomApi, scomPropertyBag, serviceObject, returnValue

'''
' Get registry values into array
'''

CONST HKLM = &H80000002
CONST REG_SZ = 1
CONST REG_EXPAND_SZ = 2
CONST REG_BINARY = 3
CONST REG_DWORD = 4
CONST REG_MULTI_SZ = 7
CONST SCOM_INFO = 2
CONST SCOM_WARNING = 1
CONST SCOM_ERROR = 0
CONST SCOM_SCRIPT_INFORMATION = 19200
CONST SCOM_SCRIPT_WARNING = 19201
CONST SCOM_SCRIPT_ERROR = 19202
CONST SCOM_DEBUG = 19999


CheckParameters 3
computerName = CStr(scriptParameters(0))
debugEnabled = CBool(scriptParameters(1))
serviceExceptions = Split(scriptParameters(2),",")

wmiQuery = "Select * from Win32_Service where StartMode = 'Auto' AND NOT DisplayName Like 'Windows%' AND NOT DisplayName Like 'SQL%'"
standardExclusions = Split("sppsvc,RemoteRegistry,clr_optimization_v4.0.30319_32,clr_optimization_v4.0.30319_64,clr_optimization_v2.0.50727_32,VSS,gupdate,TrustedInstaller,SysmonLog,msiserver,OMSDK,healthservice,cshost,LanmanWorkstation,LanmanServer,WinRM,MpsSvc,EventLog,lmhosts,Browser,Dhcp,Winmgmt,clussvc,wuauserv,gpsvc,MSMQ,DiagTrack,Spooler,RpcSs,MSDTC,Slsvc,SNMP",",")
xylemExclusions = Split("PatrolAgent,Citrix.Xip.ClientService",",")

Set wmiObject = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & computerName & "\root\cimv2")
Set automaticServices = wmiObject.ExecQuery(wmiQuery)

If NOT IsNull(automaticServices) Then
	If automaticServices.Count >= 0 And Err.Number = 0 Then
		' We got a "hit" on a service name configured in the registry
		' Create the SCOM property bag instances and return them to SCOM
		Set scomApi = CreateObject("MOM.ScriptAPI")

		For Each automaticService In automaticServices
			serviceName = automaticService.Name
			' Add one property bag per service
			LogEvent SCOM_DEBUG,SCOM_INFO,"Found automatic service: " & serviceName

			If Ubound(Filter(serviceExceptions, serviceName,True,1)) > -1 Then
				'Got match, service shound be excluded from discovery
				LogEvent SCOM_DEBUG,SCOM_INFO,"Service is ignored due to exclusion list: " & serviceName
			ElseIf Ubound(Filter(standardExclusions, serviceName,True,1)) > -1 Then
				'Got match, service shound be excluded from discovery
				LogEvent SCOM_DEBUG,SCOM_INFO,"Service is ignored due to standard exclusion list: " & serviceName
			ElseIf Ubound(Filter(xylemExclusions, serviceName,True,1)) > -1 Then
				'Got match, service shound be excluded from discovery
				LogEvent SCOM_DEBUG,SCOM_INFO,"Service is ignored due to Xylem exclusion list: " & serviceName
			Else
				' No match, service is not in exclusion list.
				' Process and add to property bag
				If Err.Number = 0 Then
					With automaticService
						Set scomPropertyBag = scomApi.CreatePropertyBag()	' Instance of a new property bag

						' Start adding values to the propertybag
						Call scomPropertyBag.AddValue("Name",Cstr(.Name))
						Call scomPropertyBag.AddValue("DisplayName",Cstr(.DisplayName))
						If .Description <> vbNull Then
							Call scomPropertyBag.AddValue("Description",Cstr(.Description))
						Else
							Call scomPropertyBag.AddValue("Description","")
						End If
						Call scomPropertyBag.AddValue("SystemName",Cstr(.SystemName))
						Call scomPropertyBag.AddValue("PathName",Cstr(.PathName))
						Call scomPropertyBag.AddValue("ProcessID",Cstr(.ProcessID))
					    If .StartName <> vbNull Then
    						Call scomPropertyBag.AddValue("ServiceUser",Cstr(.StartName))
					    Else
						    Call scomPropertyBag.AddValue("ServiceUser","")
					    End If
						Call scomPropertyBag.AddValue("State",Cstr(.State))
						Call scomPropertyBag.AddValue("Status",Cstr(.Status))
						Call scomPropertyBag.AddValue("StartMode",Cstr(.StartMode))
						Call scomPropertyBag.AddValue("ServiceType",Cstr(.ServiceType))
						Call scomPropertyBag.AddValue("TagID",Cstr(.TagID))

						Call scomApi.AddItem(scomPropertyBag)	' Add the property bag to the collection
					End With
				Else
					Select Case returnValue
						Case 242100
							LogEvent SCOM_SCRIPT_WARNING, SCOM_WARNING, "Could not properly connect to the service repository on " & computerName & ", check RunAs user rights."
						Case 242101
							LogEvent SCOM_SCRIPT_WARNING, SCOM_WARNING, "Could not match registry value """ & serviceName & """to an existing service."
						Case 424
							LogEvent SCOM_SCRIPT_WARNING, SCOM_WARNING, "Connection to WMI-service on " & computerName & " failed. Check network connections and RunAs user rights."
						Case Else
							LogEvent SCOM_SCRIPT_WARNING, SCOM_WARNING, "An unhandled script event occured, please contact your SCOM admins." & vbCrLf & "Err.number = " & Err.Number
					End Select
				End If 'End error check
			End If 'End exclusion check

			Set serviceObject = Nothing
		Next
		Call scomApi.ReturnItems()	' Return the property bag collection to SCOM
		Set scomApi = Nothing
	Else
		' Got no services from WMI query
		LogEvent SCOM_DEBUG,SCOM_INFO,"Found no automatic services" & vbCrLf & _
		"Error code: " & Err.Num & vbCrLf & _
		"Error Description: " & Err.Description
	End If
Else
	' Could not read from WMI, perhaps user rights is insufficent?
	LogEvent SCOM_DEBUG,SCOM_INFO,"Could not connect to WMI, check user rights!"
End If


'''
' Clean things up
'''
Set wmiObject = Nothing


'''
' Helper funktions
'''

Sub CheckParameters(numRequiredParams)
	'''
	' Simple check to verify the number of arguments passed
	' to the script
	' Sets the global variable scriptParameters to a Wscript.Arguments array
	'
	' Bit of a hack, yes, but it works for now.
	'''
	Dim scriptArguments
	Set scriptArguments = WScript.Arguments

	If IsNumeric(numRequiredParams) Then
		If scriptArguments.Count >= numRequiredParams Then
			Set scriptParameters = scriptArguments
		Else
			LogEvent SCOM_SCRIPT_ERROR,SCOM_ERROR,"Script was not called with all the required parameters."
			WScript.Quit
		End If
	Else
		LogEvent SCOM_SCRIPT_ERROR,SCOM_ERROR,"The CheckParameters() sub was called with numRequiredParams as not numeric."
		WScript.Quit
	End If
	Set scriptArguments = Nothing
End Sub


Sub LogEvent(logEventID, logSeverity, logMessage)
	'''
	' Logs a MOM ScriptEvent into the Operations Manager eventlog
	'''
	Dim scomApi, scriptName
	scriptName = WScript.ScriptName

	If logEventID <> SCOM_DEBUG Then
		Set scomApi = CreateObject("MOM.ScriptAPI")
		Call scomApi.LogScriptEvent(scriptName,logEventID,logSeverity,logMessage)
		Set scomApi = Nothing
	Else
		If debugEnabled Then
			Set scomApi = CreateObject("MOM.ScriptAPI")
			Call scomApi.LogScriptEvent(scriptName,logEventID,logSeverity,logMessage)
			Set scomApi = Nothing
		End If
	End If
End Sub
]]></ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PropertyBag" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
        <InputType>System!System.TriggerData</InputType>
      </ProbeActionModuleType>
      <ProbeActionModuleType ID="Atea.Windows.Service.Probe.RemoveServicePS" Accessibility="Internal">
        <Configuration>
          <xsd:element name="ServiceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="RegistryPath" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <ProbeAction ID="PSProbe" TypeID="Windows!Microsoft.Windows.PowerShellProbe">
                <ScriptName>Remove-MonitoredServiceKey.ps1</ScriptName>
                <ScriptBody><![CDATA[param(
	[string] $serviceName,
	[string] $registryPath = "SOFTWARE\Atea\WinSvc"
)

$registryPath = "HKLM:\$registryPath"

if (!(Test-Path $registryPath)) {
	Write-Host ("{0} does not exist, will skip task." -f $registryPath)
	Exit
} else {
	$regKey = Get-Item -Path $registryPath
	if (($regKey.GetValue($serviceName)) -ne $null) {
		Write-Host ("Deleting monitoring configuration for service '{0}'" -f $serviceName)
		Remove-ItemProperty -Path $registryPath -Name $serviceName -Force
		Write-Host "Done!"
		if ($regKey.GetValueNames().Count -lt 1) {
			Write-Host "No Service values left, deleting key"
			Remove-Item -Path $registryPath
			Write-Host "Done!"
		}
	} else {
		Write-Host ("Configuration for service '{0}' was not found." -f $serviceName)
	}
}
]]></ScriptBody>
                <SnapIns />
                <Parameters>
                  <Parameter>
                    <Name>serviceName</Name>
                    <Value>$Config/ServiceName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>registryPath</Name>
                    <Value>$Config/RegistryPath$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <StrictErrorHandling>true</StrictErrorHandling>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PSProbe" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Windows!Microsoft.Windows.SerializedObjectData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </ProbeActionModuleType>
      <ProbeActionModuleType ID="Atea.Windows.Service.Probe.VBSPropertyBag" Accessibility="Internal" Batching="false" PassThrough="false">
        <Configuration>
          <xsd:element minOccurs="1" name="ScriptName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" name="UseServiceDisplayName" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Debug" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction ID="PropertyBag" TypeID="Windows!Microsoft.Windows.ScriptPropertyBagProbe">
                <ScriptName>$Config/ScriptName$</ScriptName>
                <Arguments>$Config/ComputerName$ $Config/UseServiceDisplayName$ $Config/Debug$</Arguments>
                <ScriptBody><![CDATA[Option Explicit

Dim computerName, keyPath, registryObject, registryValues, serviceName, useServiceDisplayName, debugEnabled, scriptParameters, serviceClass
Dim scomApi, scomPropertyBag, serviceObject, returnValue

'''
' Get registry values into array
'''

CONST HKLM = &H80000002
CONST REG_SZ = 1
CONST REG_EXPAND_SZ = 2
CONST REG_BINARY = 3
CONST REG_DWORD = 4
CONST REG_MULTI_SZ = 7
CONST SCOM_INFO = 2
CONST SCOM_WARNING = 1
CONST SCOM_ERROR = 0
CONST SCOM_SCRIPT_INFORMATION = 19200
CONST SCOM_SCRIPT_WARNING = 19201
CONST SCOM_SCRIPT_ERROR = 19202
CONST SCOM_DEBUG = 19999


CheckParameters 3
computerName = CStr(scriptParameters(0))
useServiceDisplayName = CBool(scriptParameters(1))
debugEnabled = CBool(scriptParameters(2))

Set registryObject = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & computerName & "\root\default:StdRegProv")
keyPath = "Software\Atea\WinSvc" ' ToDo: Make this a parameter
registryObject.EnumValues HKLM, keyPath, registryValues

If NOT IsNull(registryValues) Then
	If UBound(registryValues) >= 0 And Err.Number = 0 Then
		' We got a "hit" on a service name configured in the registry
		' Create the SCOM property bag instances and return them to SCOM
		Set scomApi = CreateObject("MOM.ScriptAPI")

		For Each serviceName in registryValues
			' Add one property bag per service
			LogEvent SCOM_DEBUG,SCOM_INFO,"Found value: HKLM\" & keyPath & "\" & serviceName

			Set serviceObject = New Service
			returnValue = serviceObject.GetServiceInfo(serviceName,computerName)
			If returnValue = 0 Then
				With serviceObject
					Set scomPropertyBag = scomApi.CreatePropertyBag()	' Instance of a new property bag

					' Start adding values to the propertybag
					Call scomPropertyBag.AddValue("Name",.Name)
					Call scomPropertyBag.AddValue("DisplayName",.DisplayName)
					Call scomPropertyBag.AddValue("Description",.Description)
					Call scomPropertyBag.AddValue("SystemName",.SystemName)
					Call scomPropertyBag.AddValue("PathName",.PathName)
					Call scomPropertyBag.AddValue("ProcessID",.ProcessID)
					Call scomPropertyBag.AddValue("ServiceUser",.ServiceUser)
					Call scomPropertyBag.AddValue("State",.State)
					Call scomPropertyBag.AddValue("Status",.Status)
					Call scomPropertyBag.AddValue("StartMode",.StartMode)
					Call scomPropertyBag.AddValue("ServiceType",.ServiceType)
					Call scomPropertyBag.AddValue("TagID",.TagID)
					Call scomPropertyBag.AddValue("keyPath",keyPath)

					If useServiceDisplayName Then
						Call scomPropertyBag.AddValue("EntityDisplayName",.DisplayName)
					Else
						Call scomPropertyBag.AddValue("EntityDisplayName",.Name)
					End If

					Call scomApi.AddItem(scomPropertyBag)	' Add the property bag to the collection
				End With
			Else
				Select Case returnValue
					Case 242100
						LogEvent SCOM_SCRIPT_WARNING, SCOM_WARNING, "Could not properly connect to the service repository on " & computerName & ", check RunAs user rights."
					Case 242101
						LogEvent SCOM_SCRIPT_WARNING, SCOM_WARNING, "Could not match registry value """ & serviceName & """to an existing service."
					Case 424
						LogEvent SCOM_SCRIPT_WARNING, SCOM_WARNING, "Connection to WMI-service on " & computerName & " failed. Check network connections and RunAs user rights."
					Case Else
						LogEvent SCOM_SCRIPT_WARNING, SCOM_WARNING, "An unhandled script event occured, please contact your SCOM admins." & vbCrLf & "Err.number = " & returnValue
				End Select
			End If

			Set serviceObject = Nothing
		Next
		Call scomApi.ReturnItems()	' Return the property bag collection to SCOM
		Set scomApi = Nothing
	Else
		' No services configured in registry
		LogEvent SCOM_DEBUG,SCOM_INFO,"Found no servicenames in: HKLM\" & keyPath & "\" & vbCrLf & _
		"Error code: " & Err.Num & vbCrLf & _
		"Error Description: " & Err.Description

		' Issue #4
		' Discovery never removing services efter the only remaining string value is deleted.
		' Needs to return an empty property bag.
		Set scomApi = CreateObject("MOM.ScriptingAPI")
		Set scomPropertyBag = scomApi.CreatePropertyBag()
		Call scomApi.Return(scomPropertyBag)
		Set scomApi = Nothing
	End If
Else
	' Could not read from registry, perhaps key is missing?
	LogEvent SCOM_DEBUG,SCOM_INFO,"Failed to read from: HKLM\" & keyPath & "\"

	' Issue #4
	' Discovery never removing services efter the only remaining string value is deleted.
	' Needs to return an empty property bag.
	Set scomApi = CreateObject("MOM.ScriptAPI")
	Set scomApi = CreateObject("MOM.ScriptingAPI")
	Set scomPropertyBag = scomApi.CreatePropertyBag()
	Call scomApi.Return(scomPropertyBag)
	Set scomApi = Nothing
End If


'''
' Clean things up
'''
Set registryObject = Nothing


'''
' Helper functions
'''

Sub CheckParameters(numRequiredParams)
	'''
	' Simple check to verify the number of arguments passed
	' to the script
	' Sets the global variable scriptParameters to a Wscript.Arguments array
	'
	' Bit of a hack, yes, but it works for now.
	'''
	Dim scriptArguments
	Set scriptArguments = WScript.Arguments

	If IsNumeric(numRequiredParams) Then
		If scriptArguments.Count >= numRequiredParams Then
			Set scriptParameters = scriptArguments
		Else
			LogEvent SCOM_SCRIPT_ERROR,SCOM_ERROR,"Script was not called with all the required parameters."
			WScript.Quit
		End If
	Else
		LogEvent SCOM_SCRIPT_ERROR,SCOM_ERROR,"The CheckParameters() sub was called with numRequiredParams as not numeric."
		WScript.Quit
	End If
	Set scriptArguments = Nothing
End Sub


Sub LogEvent(logEventID, logSeverity, logMessage)
	'''
	' Logs a MOM ScriptEvent into the Operations Manager eventlog
	'''
	Dim scomApi, scriptName
	scriptName = WScript.ScriptName

	If logEventID <> SCOM_DEBUG Then
		Set scomApi = CreateObject("MOM.ScriptAPI")
		Call scomApi.LogScriptEvent(scriptName,logEventID,logSeverity,logMessage)
		Set scomApi = Nothing
	Else
		If debugEnabled Then
			Set scomApi = CreateObject("MOM.ScriptAPI")
			Call scomApi.LogScriptEvent(scriptName,logEventID,logSeverity,logMessage)
			Set scomApi = Nothing
		End If
	End If
End Sub

Class Service
	Public Name
	Public DisplayName
	Public Description
	Public SystemName
	Public ServiceUser
	Public PathName
	Public State
	Public Status
	Public StartMode
	Public ServiceType
	Public ProcessID
	Public TagID



	Private Sub Class_Initialize()
		Name = ""
		DisplayName = ""
		Description = ""
		SystemName = ""
		ServiceUser = ""
		PathName = ""
	End Sub

	Public Function GetServiceInfo(mServiceName, mComputerName)
		Dim wmi, wmiServices, wmiService, serviceClass, returnCode

		returnCode = 0	' 0 = no error
		On Error Resume Next
		Set wmi = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & mComputerName & "\root\cimv2")
		Set wmiServices = wmi.ExecQuery("Select * from Win32_Service where Name='" & mServiceName & "'")
		returnCode = Err.Number
		If wmiServices.Count > 0 And returnCode = 0 Then
			For Each wmiService In wmiServices
				If LCase(wmiService.Name) = LCase(mServiceName) Then
					Name = ClearIllegalReturnValues(wmiService.Name)
					DisplayName = ClearIllegalReturnValues(wmiService.Caption)
					Description = ClearIllegalReturnValues(wmiService.Description)
					ServiceUser = ClearIllegalReturnValues(wmiService.StartName)
					SystemName = ClearIllegalReturnValues(wmiService.SystemName)
					PathName = ClearIllegalReturnValues(wmiService.PathName)
					State = ClearIllegalReturnValues(wmiService.State)
					Status = ClearIllegalReturnValues(wmiService.Status)
					StartMode = ClearIllegalReturnValues(wmiService.StartMode)
					ServiceType = ClearIllegalReturnValues(wmiService.ServiceType)
					ProcessID = ClearIllegalReturnValues(wmiService.ProcessID)
					TagID = ClearIllegalReturnValues(wmiService.TagID)
				Else
					returnCode = 242101
				End If
			Next
		Else
			If Err.Number <> 0 Then
				returnCode = Err.Number
				Err.Clear
			Else
				returnCode = 242100
			End If
		End If
		WScript.Echo returnCode
		GetServiceInfo = returnCode
		Set wmiServices = Nothing
		Set wmi = Nothing
	End Function

	Private Function ClearIllegalReturnValues(StringToClear)
	' Check for NULL
	If IsNull(StringToClear) Then
	  StringToClear = ""
	End If
	ClearIllegalReturnValues = StringToClear
	End Function
End Class]]></ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PropertyBag" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
        <InputType>System!System.TriggerData</InputType>
      </ProbeActionModuleType>
      <WriteActionModuleType ID="Atea.Windows.Service.AdvRecoveryTask.WA" Accessibility="Internal">
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>Windows!Microsoft.Windows.PowerShellSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ServiceName" type="NonNullString" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Delay" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MaxRepeatCount" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="RepeatIntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Delay" Selector="$Config/Delay$" ParameterType="int" />
          <OverrideableParameter ID="MaxRepeatCount" Selector="$Config/MaxRepeatCount$" ParameterType="int" />
          <OverrideableParameter ID="RepeatIntervalSeconds" Selector="$Config/RepeatIntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <WriteAction ID="ServiceRestartScript" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Restart-MonitoredService.ps1</ScriptName>
                <ScriptBody><![CDATA[<#
	.Synopsis
	Restarts a windows service, with settings for wait-time for verification and repeated retries.

	.Example
	Restart-MonitoredService.ps1 -ServiceName "spooler"

	.Example
	Restart-MonitoredService.ps1 -ServiceName "spooler" -Delay 30

	.Example
	Restart-MonitoredService.ps1 -ServiceName "spooler" -Delay 30 -MaxRepeatCount 3 -RepeatIntervalSeconds 10
#>
param(
	# Name of service (not display name)
	[Parameter(Mandatory=$true)][string] $ServiceName,
	[int] $Delay = 0,
	[int] $MaxRepeatCount = 0,
	[int] $RepeatIntervalSeconds = 10,
	[string] $omAlertId,
	[switch] $Debuglogging
)

function Get-TimeStamp
{
	[string] $timeStamp = Get-Date -Format o
	Return $timeStamp
}

function Write-SCOMEvent
{
	param(
		[Parameter(Mandatory=$true)][string] $LogMessage,
		[ValidateSet(0,1,2)][int] $LogSeverity,
		[ValidateRange(0,20000)][int] $LogEventId
	)

	[string] $ScriptName = "Restart-MonitoredService.ps1"

	$omApi = New-Object -ComObject "MOM.ScriptAPI"
	$omApi.LogScriptEvent($ScriptName,$LogEventId,$LogSeverity,$LogMessage)
	$omApi = $null
}

function Test-ServiceExist ($ServiceName) {
	if (!(Get-Service -Name $ServiceName)) {
		return $false
	} else {
		return $true
	}
}

function Start-ServiceAndWait ([string] $ServiceName, [int] $WaitSeconds)
{
	Write-SCOMTaskLog -Message "Attempting to restart $ServiceName" -ElapsedSeconds $timer.Elapsed.TotalSeconds
	Write-SCOMEvent -LogMessage "Attempting to restart $ServiceName" -LogSeverity 0 -LogEventId 10101
	Restart-Service -Name $ServiceName
	Write-SCOMTaskLog -Message "Waiting for $WaitSeconds seconds to verify service state..." -ElapsedSeconds $timer.Elapsed.TotalSeconds
	Write-SCOMEvent -LogMessage "Waiting for $WaitSeconds seconds to verify `"$ServiceName`" state..." -LogSeverity 0 -LogEventId 10101
	Start-Sleep -Seconds $WaitSeconds
	$serviceObject = Get-Service -Name $ServiceName
	return [string] $serviceObject.Status
}

function Restart-ServiceWithRepeats ([int] $MaxRepeatCount, [int] $RepeatIntervalSeconds) {
	if ($MaxRepeatCount -gt 0) {
		for ($i = 1; $i -le $MaxRepeatCount; $i++) {
			Write-SCOMTaskLog -Message "Trying again ($i of $MaxRepeatCount)" -ElapsedSeconds $timer.Elapsed.TotalSeconds
			Write-SCOMEvent -LogMessage "Trying to restart `'$ServiceName`' again ($i of $MaxRepeatCount)" -LogSeverity 0 -LogEventId 10101
			[string] $serviceStatus = Start-ServiceAndWait -ServiceName $ServiceName -WaitSeconds $Delay

			if ($serviceStatus -ne "Running") {
				if ($i -eq $MaxRepeatCount) {
					Write-SCOMTaskLog -Message "$ServiceName is still not running. This was the last attempt!" -ElapsedSeconds $timer.Elapsed.TotalSeconds
					Write-SCOMEvent -LogMessage "`'$ServiceName`' is still not running. This was the last attempt!" -LogSeverity 0 -LogEventId 10101
					Write-SCOMEvent -LogMessage "Failed to recover service `'$ServiceName`' after $MaxRepeatCount attempts!" -LogSeverity 1 -LogEventId 10100
				} else {
					Write-SCOMTaskLog -Message "$ServiceName is still not running, waiting $RepeatIntervalSeconds before next try..." -ElapsedSeconds $timer.Elapsed.TotalSeconds
					Write-SCOMEvent -LogMessage "`'$ServiceName`' is still not running, waiting $RepeatIntervalSeconds before next try..." -LogSeverity 0 -LogEventId 10101
				}
				Start-Sleep -Seconds $RepeatIntervalSeconds
			} else {
				# Service has started and has been running for $Delay seconds
				$i = $MaxRepeatCount
				Write-SCOMTaskLog -Message "$ServiceName is now running..." -ElapsedSeconds $timer.Elapsed.TotalSeconds
				Write-SCOMEvent -LogMessage "`'$ServiceName`' is now running!" -LogSeverity 0 -LogEventId 10101
			}
		}
	}
}

function Write-SCOMTaskLog ([string]$Message, [single]$ElapsedSeconds = 0)
{
     Write-Host ("{0}`t{1:N2}`t{2}" -f (Get-TimeStamp),$ElapsedSeconds,$Message)
}

function Main () {
	Write-SCOMTaskLog -Message "Starting Advanced Recovery Script" -ElapsedSeconds 0
	$timer = [System.Diagnostics.Stopwatch]::StartNew()

	if ((Test-ServiceExist -ServiceName $ServiceName) -eq $false) {
		Write-SCOMTaskLog -Message "$ServiceName - No such service exists on the system." -ElapsedSeconds $timer.Elapsed.TotalSeconds
	} else {
		[string] $serviceStatus = Start-ServiceAndWait $ServiceName -WaitSeconds $Delay

		if ($serviceStatus -ne "Running") {
			Write-SCOMTaskLog -Message "$ServiceName is not running..." -ElapsedSeconds $timer.Elapsed.TotalSeconds
			Restart-ServiceWithRepeats -MaxRepeatCount $MaxRepeatCount -RepeatIntervalSeconds $RepeatIntervalSeconds
		} else {
			Write-SCOMTaskLog -Message "$ServiceName is running..." -ElapsedSeconds $timer.Elapsed.TotalSeconds
		}
	}
	$timer.Stop()
}

Main]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>ServiceName</Name>
                    <Value>$Config/ServiceName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Delay</Name>
                    <Value>$Config/Delay$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>MaxRepeatCount</Name>
                    <Value>$Config/MaxRepeatCount$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>RepeatIntervalSeconds</Name>
                    <Value>$Config/RepeatIntervalSeconds$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="ServiceRestartScript" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Windows!Microsoft.Windows.SerializedObjectData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
    </ModuleTypes>
  </TypeDefinitions>
  <Monitoring>
    <Discoveries>
      <Discovery ID="Atea.Windows.Service.AutoServiceDiscovery" Enabled="false" Target="Windows!Microsoft.Windows.Server.Computer" ConfirmDelivery="true" Remotable="false" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Atea.Windows.Service.Service">
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="ServiceName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="ServiceProcessName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="DisplayName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="Description" />
          </DiscoveryClass>
        </DiscoveryTypes>
        <DataSource ID="ServiceDS" TypeID="Atea.Windows.Service.AutoServiceDiscoveryDS">
          <IntervalSeconds>14400</IntervalSeconds>
          <ComputerName>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <TimeoutSeconds>300</TimeoutSeconds>
          <Debug>false</Debug>
          <ClassId>$MPElement[Name="Atea.Windows.Service.Service"]$</ClassId>
          <InstanceSettings>
            <Settings>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/ServiceName$</Name>
                <Value>$Data/Property[@Name='Name']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/DisplayName$</Name>
                <Value>$Data/Property[@Name='DisplayName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/ServiceProcessName$</Name>
                <Value>$Data/Property[@Name='PathName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/Description$</Name>
                <Value>$Data/Property[@Name='Description']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name>
                <Value>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value>
              </Setting>
            </Settings>
          </InstanceSettings>
          <Filter>
            <RegExExpression>
              <ValueExpression>
                <XPathQuery>Property[@Name='ServiceType']</XPathQuery>
              </ValueExpression>
              <Operator>ContainsSubstring</Operator>
              <Pattern>Own Process</Pattern>
            </RegExExpression>
          </Filter>
          <ServiceExceptions>sppsvc,RemoteRegistry</ServiceExceptions>
        </DataSource>
      </Discovery>
      <Discovery ID="Atea.Windows.Service.AutoSharedServiceDiscovery" Enabled="false" Target="Windows!Microsoft.Windows.Server.Computer" ConfirmDelivery="true" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Atea.Windows.Service.SharedService">
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="ServiceName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="ServiceProcessName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="DisplayName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="Description" />
          </DiscoveryClass>
        </DiscoveryTypes>
        <DataSource ID="ServiceDS" TypeID="Atea.Windows.Service.AutoServiceDiscoveryDS">
          <IntervalSeconds>14400</IntervalSeconds>
          <ComputerName>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <TimeoutSeconds>300</TimeoutSeconds>
          <Debug>false</Debug>
          <ClassId>$MPElement[Name="Atea.Windows.Service.SharedService"]$</ClassId>
          <InstanceSettings>
            <Settings>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/ServiceName$</Name>
                <Value>$Data/Property[@Name='Name']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/DisplayName$</Name>
                <Value>$Data/Property[@Name='DisplayName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/ServiceProcessName$</Name>
                <Value>$Data/Property[@Name='PathName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/Description$</Name>
                <Value>$Data/Property[@Name='Description']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name>
                <Value>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value>
              </Setting>
            </Settings>
          </InstanceSettings>
          <Filter>
            <RegExExpression>
              <ValueExpression>
                <XPathQuery>Property[@Name='ServiceType']</XPathQuery>
              </ValueExpression>
              <Operator>ContainsSubstring</Operator>
              <Pattern>Share Process</Pattern>
            </RegExExpression>
          </Filter>
          <ServiceExceptions>sppsvc,RemoteRegistry</ServiceExceptions>
        </DataSource>
      </Discovery>
      <Discovery ID="Atea.Windows.Service.Service.Discovery" Enabled="true" Target="Atea.Windows.Service.Seed" ConfirmDelivery="true" Remotable="false" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Atea.Windows.Service.Service">
            <Property TypeID="System!System.Entity" PropertyID="DisplayName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="ServiceName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="ServiceProcessName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="DisplayName" />
            <Property TypeID="MSNL!Microsoft.SystemCenter.NTService" PropertyID="Description" />
          </DiscoveryClass>
        </DiscoveryTypes>
        <DataSource ID="ServiceDS" TypeID="Atea.Windows.Service.ServiceDiscoveryDS">
          <IntervalSeconds>14400</IntervalSeconds>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <TimeoutSeconds>300</TimeoutSeconds>
          <ScriptName>AteaWinSvcServiceDiscoveryDS.vbs</ScriptName>
          <UseServiceDisplayName>false</UseServiceDisplayName>
          <Debug>false</Debug>
          <ClassId>$MPElement[Name="Atea.Windows.Service.Service"]$</ClassId>
          <InstanceSettings>
            <Settings>
              <Setting>
                <Name>$MPElement[Name='System!System.Entity']/DisplayName$</Name>
                <Value>$Data/Property[@Name='EntityDisplayName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/ServiceName$</Name>
                <Value>$Data/Property[@Name='Name']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/DisplayName$</Name>
                <Value>$Data/Property[@Name='DisplayName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/ServiceProcessName$</Name>
                <Value>$Data/Property[@Name='PathName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name='MSNL!Microsoft.SystemCenter.NTService']/Description$</Name>
                <Value>$Data/Property[@Name='Description']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name>
                <Value>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value>
              </Setting>
            </Settings>
          </InstanceSettings>
        </DataSource>
      </Discovery>
      <Discovery ID="Atea.Windows.Service.Seed.Discovery" Enabled="true" Target="Windows!Microsoft.Windows.Computer" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Atea.Windows.Service.Seed">
            <Property TypeID="System!System.Entity" PropertyID="DisplayName" />
            <Property TypeID="Atea.Windows.Service.Seed" PropertyID="RegistryPath" />
          </DiscoveryClass>
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.FilteredRegistryDiscoveryProvider">
          <ComputerName>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <RegistryAttributeDefinitions>
            <RegistryAttributeDefinition>
              <AttributeName>AteaWinSvcKey</AttributeName>
              <Path>Software\Atea\WinSvc</Path>
              <PathType>0</PathType>
              <AttributeType>0</AttributeType>
            </RegistryAttributeDefinition>
          </RegistryAttributeDefinitions>
          <Frequency>14400</Frequency>
          <ClassId>$MPElement[Name="Atea.Windows.Service.Seed"]$</ClassId>
          <InstanceSettings>
            <Settings>
              <Setting>
                <Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name>
                <Value>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="System!System.Entity"]/DisplayName$</Name>
                <Value>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="Atea.Windows.Service.Seed"]/RegistryPath$</Name>
                <Value>Software\Atea\WinSvc</Value>
              </Setting>
            </Settings>
          </InstanceSettings>
          <Expression>
            <SimpleExpression>
              <ValueExpression>
                <XPathQuery Type="String">Values/AteaWinSvcKey</XPathQuery>
              </ValueExpression>
              <Operator>Equal</Operator>
              <ValueExpression>
                <Value Type="String">true</Value>
              </ValueExpression>
            </SimpleExpression>
          </Expression>
        </DataSource>
      </Discovery>
    </Discoveries>
    <Rules>
      <Rule ID="Atea.Windows.Service.AdvServiceRecoveryFailed" Target="MSNL!Microsoft.SystemCenter.OwnProcessNTService" Enabled="true" ConfirmDelivery="false" Remotable="false" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">10100</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>$Target/Property[Type='MSNL!Microsoft.SystemCenter.NTService']/ServiceName$</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>2</Severity>
            <AlertMessageId>$MPElement[Name="Atea.Windows.Service.AdvServiceRecoveryFailed.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
          </WriteAction>
        </WriteActions>
      </Rule>
    </Rules>
    <Tasks>
      <Task ID="Atea.Windows.Service.Task.AddService" Accessibility="Public" Target="Windows!Microsoft.Windows.Computer" Enabled="true" Timeout="300" Remotable="false">
        <Category>Maintenance</Category>
        <ProbeAction ID="Probe" TypeID="Atea.Windows.Service.Probe.AddServicePS">
          <ServiceName>CHANGEME</ServiceName>
          <RegistryPath>SOFTWARE\Atea\WinSvc</RegistryPath>
          <TimeoutSeconds>300</TimeoutSeconds>
        </ProbeAction>
      </Task>
      <Task ID="Atea.Windows.Service.Task.ListRunningServices" Accessibility="Public" Remotable="false" Enabled="true" Target="Windows!Microsoft.Windows.Computer">
        <Category>Maintenance</Category>
        <ProbeAction ID="Probe" TypeID="Windows!Microsoft.Windows.PowerShellProbe">
          <ScriptName>Get-RunningServices.ps1</ScriptName>
          <ScriptBody><![CDATA[Get-WMIObject -query "select * from Win32_Service where State='Running'" | Format-Table Name,DisplayName -AutoSize
]]></ScriptBody>
          <TimeoutSeconds>300</TimeoutSeconds>
        </ProbeAction>
      </Task>
      <Task ID="Atea.Windows.Service.Task.RemoveService" Accessibility="Public" Target="Atea.Windows.Service.Service" Enabled="true" Timeout="300" Remotable="false">
        <Category>Maintenance</Category>
        <ProbeAction ID="Probe" TypeID="Atea.Windows.Service.Probe.RemoveServicePS">
          <ServiceName>$Target/Property[Type='MSNL!Microsoft.SystemCenter.NTService']/ServiceName$</ServiceName>
          <RegistryPath>SOFTWARE\Atea\WinSvc</RegistryPath>
          <TimeoutSeconds>300</TimeoutSeconds>
        </ProbeAction>
      </Task>
    </Tasks>
    <Monitors>
      <UnitMonitor ID="Atea.Windows.Service.RecoveryMonitor" Accessibility="Internal" Enabled="false" Target="MSNL!Microsoft.SystemCenter.NTService" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>AvailabilityHealth</Category>
        <OperationalStates>
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type='Windows!Microsoft.Windows.Computer']/PrincipalName$</ComputerName>
          <ServiceName>$Target/Property[Type='MSNL!Microsoft.SystemCenter.NTService']/ServiceName$</ServiceName>
          <CheckStartupType>true</CheckStartupType>
        </Configuration>
      </UnitMonitor>
    </Monitors>
    <Recoveries>
      <Recovery ID="Atea.Windows.Service.Service.AdvRecoveryTask" Accessibility="Public" Target="MSNL!Microsoft.SystemCenter.NTService" Enabled="false" ExecuteOnState="Error" Monitor="Atea.Windows.Service.RecoveryMonitor" ResetMonitor="true" Timeout="300" Remotable="false">
        <Category>AvailabilityHealth</Category>
        <WriteAction ID="StartService" TypeID="Atea.Windows.Service.AdvRecoveryTask.WA">
          <ServiceName>$Target/Property[Type='MSNL!Microsoft.SystemCenter.NTService']/ServiceName$</ServiceName>
          <Delay>20</Delay>
          <MaxRepeatCount>0</MaxRepeatCount>
          <RepeatIntervalSeconds>10</RepeatIntervalSeconds>
          <TimeoutSeconds>600</TimeoutSeconds>
        </WriteAction>
      </Recovery>
      <Recovery ID="Atea.Windows.Service.Service.RecoveryTask" Accessibility="Public" Target="MSNL!Microsoft.SystemCenter.NTService" Enabled="true" ExecuteOnState="Error" Monitor="Atea.Windows.Service.RecoveryMonitor" ResetMonitor="true" Timeout="300" Remotable="false">
        <Category>AvailabilityHealth</Category>
        <WriteAction ID="StartService" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>%windir%\system32</WorkingDirectory>
          <CommandLine>start "$Target/Property[Type='MSNL!Microsoft.SystemCenter.NTService']/ServiceName$"</CommandLine>
          <TimeoutSeconds>300</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
    </Recoveries>
  </Monitoring>
  <Presentation>
    <StringResources>
      <StringResource ID="Atea.Windows.Service.AdvServiceRecoveryFailed.AlertMessage" />
    </StringResources>
  </Presentation>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="true">
      <DisplayStrings>
        <DisplayString ElementID="Atea.Windows.Service.AutoServiceDiscovery">
          <Name>Atea Windows Automatic Service Discovery</Name>
          <Description>Discover all windows services running in it's own process configured to start automatically.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AutoSharedServiceDiscovery">
          <Name>Atea Windows Automatic Service (svchost) Discovery</Name>
          <Description>Discover all windows services running in a shared process (svchost) configured to start automatically.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Service.Discovery">
          <Name>Atea Windows Service Discovery</Name>
          <Description>Script based (vbs) discovery that instantiates services condigured through registry or the "Add Monitored Service" task on Windows Computer objects.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Seed.Discovery">
          <Name>Atea Windows Service Server Seed Discovery</Name>
          <Description>Initial Seed discovery</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Seed.Discovery" SubElementID="DS">
          <Name>Atea Windows Service Server Discovery Data Source</Name>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.RecoveryMonitor">
          <Name>Service Recovery Monitor</Name>
          <Description>A service monitor with auto-restart enabled.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.RecoveryMonitor" SubElementID="Running">
          <Name>Running</Name>
          <Description>Running</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.RecoveryMonitor" SubElementID="NotRunning">
          <Name>NotRunning</Name>
          <Description>NotRunning</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AdvServiceRecoveryFailed">
          <Name>Windows Service Adv Recovery Failed</Name>
          <Description>Alerts on events indicating a failure to recover a stopped Windows service</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AdvServiceRecoveryFailed.AlertMessage">
          <Name>Failed to Recovery Service</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Task.AddService">
          <Name>Add Monitored Service</Name>
          <Description>Use this task to add a monitored service on this computer. Use overrides to set the service name.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Task.ListRunningServices">
          <Name>List Running Services</Name>
          <Description>Executes a simple powershell script on the agent, returning a list of running windows services and their Service Name and Display Name.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Task.RemoveService">
          <Name>Remove Monitored Service</Name>
          <Description>Use this task to remove a monitored service on this computer. 
          Only works on services discovered by Atea Windows Service registry keys.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Service.AdvRecoveryTask">
          <Name>Advanced Service Restart</Name>
          <Description>Provides options to wait before clearing alert, repeated retries, retry delays...
          Make sure that TimeoutSeconds is set to allow the script to execute all repeats, delays and repeat-waits.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Service.RecoveryTask">
          <Name>Restart Windows Service - Recovery Task</Name>
          <Description>Will automatically restart the service if stopped. Will run once each time the monitor enters a critical state.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Monitoring">
          <Name>Atea Windows Service Monitoring</Name>
          <Description>Extends and simplifies monitoring of Windows Services.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Seed">
          <Name>Atea Windows Service Seed</Name>
          <Description>A class for servers that Hosts monitored windows services</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Seed" SubElementID="RegistryPath">
          <Name>Atea Windows Service Seed Configuration Path</Name>
          <Description>Where the configuration for the monitored services are stored.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Service">
          <Name>Windows Service - Own Process</Name>
          <Description>A windows service running in it's own process, discovered by the Atea Windows Service Monitoring pack.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.SharedService">
          <Name>Windows Service - Shared Process</Name>
          <Description>A windows service running in a shared process (svchost), discovered by the Atea Windows Service Monitoring pack.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AutoServiceDiscoveryDS">
          <Name>Atea Windows Service Automatic Service Discovery DataSource</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AutoServiceDiscoveryDS" SubElementID="IntervalSeconds">
          <Name>Interval (seconds)</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AutoServiceDiscoveryDS" SubElementID="Debug">
          <Name>Debug Logging</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AutoServiceDiscoveryDS" SubElementID="TimeoutSeconds">
          <Name>Script Timeout (seconds)</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AutoServiceDiscoveryDS" SubElementID="ServiceExceptions">
          <Name>Service Exclusions</Name>
          <Description>Comma-separated list of services to exclude from discovery.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.ServiceDiscoveryDS">
          <Name>Atea Windows Service ServiceDiscovery Data Source Module</Name>
          <Description>Atea Windows Service ServiceDiscovery Data Source Module</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.ServiceDiscoveryDS" SubElementID="Debug">
          <Name>Use Debug Logging</Name>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.ServiceDiscoveryDS" SubElementID="IntervalSeconds">
          <Name>Interval Seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.ServiceDiscoveryDS" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.ServiceDiscoveryDS" SubElementID="UseServiceDisplayName">
          <Name>Use Service Display Name</Name>
          <Description>Use service display name instead of service name as display name of discovered services.</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AutoServiceDiscoveryVBSProbe">
          <Name>Atea Windows Automatic Service Discovery Probe</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Probe.VBSPropertyBag">
          <Name>Atea Windows Service Probe VBS PropertyBag</Name>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.Probe.VBSPropertyBag" SubElementID="PropertyBag">
          <Name>Atea Windows Service Probe VBS PropertyBag Module</Name>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AdvRecoveryTask.WA">
          <Name>Windows Service Advanced Recovery Task Write Action</Name>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AdvRecoveryTask.WA" SubElementID="Delay">
          <Name>Delay (in seconds)</Name>
          <Description>For how long should the script wait before checking status on the windows service?</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AdvRecoveryTask.WA" SubElementID="MaxRepeatCount">
          <Name>Max Repeat Count</Name>
          <Description>How many times to retry starting the service</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AdvRecoveryTask.WA" SubElementID="RepeatIntervalSeconds">
          <Name>Repeat Interval (in seconds)</Name>
          <Description>The delay between each retry</Description>
        </DisplayString>
        <DisplayString ElementID="Atea.Windows.Service.AdvRecoveryTask.WA" SubElementID="TimeoutSeconds">
          <Name>Timeout (in seconds)</Name>
          <Description>Max execution time of the script. Efter this, SCOM will kill the task.</Description>
        </DisplayString>
      </DisplayStrings>
      <KnowledgeArticles></KnowledgeArticles>
    </LanguagePack>
  </LanguagePacks>
</ManagementPack>